---
layout: post
title:  "js? es6!"
crawlertitle: "js? es6"
summary: "js? es6"
date:   2018-04-12 11:00 +0900
categories: posts
tags: 'basic'
author: codeMonkey
---

### js? ES6! ###

#### 기존 js를 알아보며, ES6에 대해서도 알아보겠습니다. ####

##### scope #####
- scope란 name-binding, name-binding는 말 그대로 이름을 연결 하는 것.
- scope란 유효한 범위를 나타낸다. 이러한 범위를 scope block 이라고 한다.

- 유효범위?
    * ***global scope*** - 전역 스코프, 최상위 유효범위(window)
    * ***local scope - function scope*** - 함수 지역 스코프

``` html
예제 1)

<div id="div0"></div>
<div id="div1"></div>
<div id="div2"></div>

<script>
window.onload = function() {
    var numDivs = 3;
    for (var i = 0; i < numDivs; i++) {
        var div = document.getElementById("div" + i);
        div.onclick = function() {
            console.log("You just clicked on div number " + i);
        };
    }
};
</script>
```

위의 소스는 ```div```태그를 클릭하면 콘솔로 몇 번째 ```div```인지 보여주는 예제 입니다. 실제로 실행하면 ```i``` 값은 항상 '3'이 찍힙니다.

``` html
예제 1 수정)

<div id="div0"></div>
<div id="div1"></div>
<div id="div2"></div>

<script>
window.onload = function() {
    var numDivs = 3;
    for (var i = 0; i < numDivs; i++) {
        var div = document.getElementById("div" + i);
        div.onclick = (function(divNum) {
            return function() {
                console.log("You just clicked on div number " + divNum);
            };
        })(i);
    }
};
</script>
```
원하는 결과를 위해 위와 같이 소스를 수정해야 합니다.<br>
위의 예제를 이해하기 위해서는 scope, closure의 이해가 필요 합니다.

- ***scope***
    * ***Scope chain***
        * 값을 local 범위에서 상위 범위로 찾는 것.
    * ***Dynamic dimension***
        * 변수, 함수 등이 선언되는 시점의 scope를 기준으로 삼는다.
        * 스코프 체인에 스코프가 쌓이지 않고 계속 교체된다.
    * ***Lexical dimension***
        * 변수, 함수 등이 호출 되는 시점의 scope를 기준으로 삼는다.
        * 스코프가 계속 쌓인다.

- ***closure***
    * ***함수가 끝난 후에도(return) 값을 사용 할 수있다.***

위의 내용이 이해가 간다면, 클로저를 이해하기 쉽습니다. 

```예제 1)```에서 ```i``` 값이 '3'으로 교체가 됬었다면, <br>
```예제 1 수정)```에서는 ```i``` 값이 교체가 되지 않았습니다. ```divNum``` 인자의 값으로 ```i```값을 주고, ```return``` 했기 때문에 실행 함수는 끝이 났지만, 실제로는 기존의 값은 남아 있다. 결국 여기서 ```closure```를 사용한 이유는 ```Lexical scope``` 값을 쓰기 위해서 였습니다.


또 ES6 에서는 ```var i = 0;``` 이 부분을<br>
```let i = 0;``` ```let``` 으로 수정하면 ```closure```를 사용하지 않아도 원하는 결과 값이 나옵니다. 


``` html
예제 1)

<div id="div0"></div>
<div id="div1"></div>
<div id="div2"></div>

<script>
window.onload = function() {
    var numDivs = 3;
    for (let i = 0; i < numDivs; i++) { /* let으로 수정 */
        var div = document.getElementById("div" + i);
        div.onclick = function() {
            console.log("You just clicked on div number " + i);
        };
    }
};
</script>
```

```var```를 쓰면 ```예제 1 수정)``` 같이 뭔가 코드가 어려워 지는데요. ```ES6의 let```을 쓰는 것이 나은 방법 같습니다.

##### ES6 - let #####

***let*** 은 ```var```와 같은 역활을 하지만, block scope를 가지고 있습니다. 즉 ```{  }```블록도 유효 범위로 친다는 이야기 입니다.

```javascript
let x = 1;

if (x === 1) {
    let x = 2;

    console.log(x);
    // expected output: 2
}
console.log(x);
// expected output: 1
```

>let은 변수가 선언된 블록, 구문 또는 표현식 내에서만 유효한 변수를 선언한다. 이는 var 키워드가 블록 범위를 무시하고 전역 변수나 함수 지역 변수로 선언되는 것과 다른 점이다. 
[MDN](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Statements/let)

```let```은 전역 객체의 속성 값을 생성하지 않습니다.

```javascript
var x = 'global';
let y = 'global';
console.log(this.x); // "global" 전역 객체의 속성 x를 생성
console.log(this.y); // undefined 전역 객체의 속성 y를 생성하지 않음
```